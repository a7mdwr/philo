==> philo.h <==
#ifndef PHILO_H
# define PHILO_H


# define TAB '\t'
# define BACKSPACE '\b'
# define CARRIAGE '\r'
# define SPACE ' '
# include <pthread.h>
# include <unistd.h>
# include <stdio.h>
# include <time.h>
# include <string.h>
# include <limits.h>
# include <stdlib.h> 

typedef struct s_share
{
    pthread_mutex_t *left_fork;
    pthread_mutex_t *right_fork;
    pthread_mutex_t *forks;
}t_share;


typedef struct s_philo
{
    char **array;
    int philos;
    int id;
    int time_to_die;
    int time_to_eat;
    int time_to_sleep;
    int must_eat;
    int died;
    t_share *shared;
} t_philo;


int 	ft_atoi(const char *str);
int 	ft_isdigit(int c);
int     check(t_philo *s, char **av, int ac);
void	ft_bzero(void *s, size_t n);
void    *routine(void *arg);
void	*ft_malloc(size_t size);

#endif
==> pars.c <==
#include "philo.h"


int check(t_philo *s, char **av, int ac)
{
    int j;
    int i;

    j = 1;
    s->array = av;
    while(ac > j)
    {
        i = 0;
        while(s->array[j][i])
        {
            if(!ft_isdigit(s->array[j][i]))
                return (perror("Error : Non-numeric"), 0);
            i++;
        }
        j++;
    }
    return (1);
}
==> philo.c <==

#include "philo.h"

int    init_threads(t_philo *s)
{
    s->philos = ft_atoi(s->array[1]);
    s->time_to_die = ft_atoi(s->array[2]);
    s->time_to_eat = ft_atoi(s->array[3]);
    s->time_to_sleep = ft_atoi(s->array[4]);
    s->shared->forks = ft_malloc(sizeof(pthread_mutex_t) * s->philos);
    pthread_mutex_init(s->shared->left_fork, NULL);
    pthread_mutex_init(s->shared->right_fork, NULL);
    if (!s->philos || !s->time_to_die || !s->time_to_eat || !s->time_to_sleep)
        return (perror("Error: Values must be > 0"), 0);
    if (s->array[5])
    {
        s->must_eat = ft_atoi(s->array[5]);
        if (s->must_eat <= 0)
            return (perror("Error: (must_eat) must be > 0"), 0);
    }
    else
        s->must_eat = -1;
    return (1);
}


int main(int ac, char **av)
{
    t_philo s;
    pthread_t *threads;
    int i;

    i = 0;
    ft_bzero(&s, sizeof(t_philo));
    if (ac != 5 && ac != 6)
    return(perror("Error: wrong number of arguments"), 0);
    if(!check(&s, av, ac) || !init_threads(&s))
    return(0);
    threads = malloc(sizeof(pthread_t) * s.philos);
    while(i < s.philos)
    {
        if(pthread_create(&threads[i], NULL, &routine, NULL) != 0)
            return (perror("Error : faild to creat thread"), 0);
        i++;
    }
    i = 0;
    while(i < s.philos)
    {
        pthread_join(threads[i], NULL);
        i++;
    }
    free(threads);
}
==> routine.c <==
#include "philo.h"

void *routine(void *arg)
{
    t_philo *s = (t_philo *)arg;
    while (1)
    {
        printf("philo number %d is thinking", s->philos);
        usleep(1000 * 1000);
        printf("philo number %d has taken a fork", s->philos);
        pthread_mutex_lock(s->shared->left_fork);
        pthread_mutex_lock(s->shared->right_fork);
        printf("philo number %d is eating", s->philos);
        usleep(1000 * 1000);
        pthread_mutex_unlock(s->shared->left_fork);
        pthread_mutex_unlock(s->shared->right_fork);
        printf("philo number %d is sleeping", s->philos);
        if (s->died == 1)
            printf("philo number %d died", s->philos);
    }
    return NULL;
}
==> utlis.c <==
#include "philo.h"

void	ft_bzero(void *s, size_t n)
{
	memset(s, 0, n);
}

int	ft_atoi(const char *str)
{
	size_t	i;
	long	result;
	int		sign;

	sign = 1;
	result = 0;
	i = 0;
	while ((str[i] >= 9 && str[i] <= 13) || str[i] == 32)
		i++;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		result = result * 10 + (str[i] - '0');
		if (sign == 1 && result > INT_MAX)
		{
			perror("Error: Values must be < 2147483647");
			return (exit(1), 0);
		}
		i++;
	}
	return ((int)(result * sign));
}


int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	else
		return (0);
}

void	*ft_malloc(size_t size)
{
	void	*a;

	a = malloc(size);
	if (a == NULL)
	{
		write(2, "Error: malloc failed\n", 20);
		exit(1);
	}
	return (a);
}
==> Makefile <==
clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all
